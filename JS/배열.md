# 배열

## Array.length

배열의 길이를 반환

```JavaScript
const numbers = [5, 12, 3, 1234];

console.log(numbers.length);    // 4
console.log([1, 2].length);     // 2
```

---

## Array.find()

주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환. 그런 요소가 없다면 undefined를 반환

```JavaScript
const numbers = [5, 12, 3, 1234];
const found = numbers.find((element) => element > 10);
console.log(found); // 12

const found = numbers.find((element) => element > 10000);
console.log(found); // undefined
```

---

## Array.findIndex()

주어진 판별 함수를 만족하는 첫 번째 요소의 인덱스를 반환.

```JavaScript
const numbers = [5, 12, 3, 1234];

const a = numbers.findIndex((n) => n > 10);
console.log(a); // 1

```

---

## Array.concat()

두 배열을 이어 붙인다.

```JavaScript
const numbers = [5, 12, 3, 1234];
const fruits = ['Apple', 'Banana', 'Cherry'];
console.log(numbers.concat(fruits));    // [5, 12, 3, 1234, 'Apple', 'Banana', 'Cherry']

```

---

## <span style = "color:tomato">Array.forEach()</span>

배열의 요소를 출력하는 다른 방법. 반복문보다 이게 더 좋다고 들음!!

```JavaScript
const fruits = ['Apple', 'Banana', 'Cherry'];

fruits.forEach(function (element, index, array) {
  console.log(element, index, array);
});
// Apple 0 (3) ['Apple', 'Banana', 'Cherry']
// Banana 1 (3) ['Apple', 'Banana', 'Cherry']
// Cherry 2 (3) ['Apple', 'Banana', 'Cherry']

fruits.forEach(function (el) {
  console.log(el);
});
// Apple
// Banana
// Cherry
```

---

## Array.map()

forEach()와는 다르게 새로운 배열이 만들어져서 출력

```JavaScript
const a = fruits.map(function (el, i) {
  return `${el}-${i}`;
});
console.log(a); // (3) ['Apple-0', 'Banana-1', 'Cherry-2']
```

객체 형식으로도 사용 가능

```JavaScript
const a = fruits.map(function (el, i) {
  return {
    id: i,
    name: el,
  };
});
```

---

## Array.filter()

결과 데이터가 배열에 들어감

```JavaScript
const numbers = [5, 12, 3, 1234];
const a = numbers.map((number) => {
  return number < 4;
});
console.log(a); // [false, false, true, false]

const b = numbers.filter((number) => {
  return number < 4;
});
console.log(b); // [3]
```

---

## Array.includes()

값이 배열에 들어 있는지 아닌지 출력.

```JavaScript
const numbers = [5, 12, 3, 1234];
const fruits = ['Apple', 'Banana', 'Cherry'];

const a = numbers.includes(1234);
console.log(a); // true

const b = fruits.includes('Kiwi');
console.log(b); // false
```

---

## Array.push(), Array.unshift()

### 원본이 수정된다!!!

- push()
  - 배열 가장 뒤에 삽입
- unshift()
  - 배열 가장 앞에 삽입

```JavaScript
const numbers = [5, 12, 3, 1234];

numbers.push(100);
console.log(numbers);   // [5, 12, 3, 1234, 100]

numbers.unshift(10000);
console.log(numbers);   // [10000, 5, 12, 3, 1234, 100]
```

---

## Array.reverse()

배열을 뒤집는다. 원본 수정!!

```JavaScript
const numbers = [1, 2, 3, 4];

numbers.reverse();
console.log(numbers);   // [4, 3, 2, 1]
```

---

## Array.splice()

배열의 원소를 삭제. 원본 수정!!

```JavaScript
const numbers = [1, 2, 3, 4];

numbers.splice(2, 1);   // 인덱스 2번부터 1개를 지워라!
console.log(numbers);   // [1, 2, 4]

numbers.splice(2, 1, 999);  // 인덱스 2번부터 1개를 지우고 그 위치에 999를 삽입!
console.log(numbers);   // [1, 2, 999, 4]
```
